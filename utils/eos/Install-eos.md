# Install instructions of EOS

Downloading EOS source code
```
git clone https://github.com/eosio/eos --recursive
```

Building EOS from Dawn (v3.0) branch
```
cd eos
git checkout DAWN-2018-01-25
./build.sh ubuntu
```

Go for a coffee. The install script needs to download and install a few dependencies. After of that will compile all the EOS source code.

After a while, if everything worked fine, you should have everything ready in build folder. Execute eosd specifying a new data directory. First time should fails.
```
cd build
mkdir data
programs/eosd/eosd --data-dir data

...
2315734ms            main.cpp:63                   main                 ] 10 assert_exception: Assert Exception
fc::exists( my->genesis_file ): unable to find genesis file '', check --genesis-json argument
...

```

Genesis JSON file is missing so add the following properties to the data/config.ini file.


```
# Load the testnet genesis state, which creates some initial block producers with the default key
genesis-json = genesis.json
# Enable production on a stale chain, since a single-node test chain is pretty much always stale
enable-stale-production = true
# Enable block production with the testnet producers
producer-name = inita
producer-name = initb
producer-name = initc
producer-name = initd
producer-name = inite
producer-name = initf
producer-name = initg
producer-name = inith
producer-name = initi
producer-name = initj
producer-name = initk
producer-name = initl
producer-name = initm
producer-name = initn
producer-name = inito
producer-name = initp
producer-name = initq
producer-name = initr
producer-name = inits
producer-name = initt
producer-name = initu
# Load the block producer plugin, so you can produce blocks
plugin = eosio::producer_plugin
# Wallet plugin
plugin = eosio::wallet_api_plugin
# As well as API and HTTP plugins
plugin = eosio::chain_api_plugin
plugin = eosio::http_plugin

```

Run again, now should works
```
programs/eosd/eosd --data-dir data
```


## Creating a Wallet

Create wallet
```
programs/eosc/eosc wallet create
```

Import wallet using the example private key provided in the config.ini
```
programs/eosc/eosc wallet import 5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3
    imported private key for: EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV
```

## Creating accounts

Create owner key
```
programs/eosc/eosc create key
Private key: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Public key: EOSXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```

Create active key
```
programs/eosc/eosc create key
Private key: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Public key: EOSXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```

Run the create command where inita is the account authorizing the creation of the currency account and PUBLIC_KEY_1 and PUBLIC_KEY_2 are the values generated by the create key command
```
programs/eosc/eosc create account inita currency PUB_KEY1 PUB_KEY2
```

You should have a JSON file including the transaction id:
```
"transaction_id": "6f84dafcdc8a156d17772d30148af7b4efbb5100e26f577c24b9d7cd672dd11e",
```

```
programs/eosc/eosc get account currency

{
  "account_name": "currency",
  "eos_balance": "0.0000 EOS",
  "staked_balance": "0.0001 EOS",
  "unstaking_balance": "0.0000 EOS",
  "last_unstaking_time": "1969-12-31T23:59:59",
  "permissions": [{
      "perm_name": "active",
      "parent": "owner",
      "required_auth": {
        "threshold": 1,
        "keys": [{
            "key": "EOS71DiMz5vnBisyS8X2CGwiPK9HH2ihUQCYLMDBGCu68eUBHP6hf",
            "weight": 1
          }
        ],
        "accounts": []
      }
    },{
      "perm_name": "owner",
      "parent": "",
      "required_auth": {
        "threshold": 1,
        "keys": [{
            "key": "EOS4zUFm3B6kXq81sQksKQgatB3UjkUWRrLyzVgtY4UpBfTUhXSYu",
            "weight": 1
          }
        ],
        "accounts": []
      }
    }
  ]
}
```

Now import the active private key generated previously in the wallet:
```
programs/eosc/eosc wallet import XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```

## Upload sample "currency" contract to blockchain
Before uploading a contract, verify that there is no current contract
```
programs/eosc/eosc get code currency
code hash: 0000000000000000000000000000000000000000000000000000000000000000
```

Upload a sample contract:
```
programs/eosc/eosc set contract currency contracts/currency/currency.wast contracts/currency/currency.abi 
Reading WAST...
Assembling WASM...
Publishing contract...
{
  "transaction_id": "4b71758780063dfaac616d9ef644060033fd9e578acfb7705c8687fc8496f8a5",
 ...
}
```

Verify that the code has been set with the following command
```
programs/eosc/eosc get code currency
code hash: 86968a9091ce32255777e2017fccaede8cea2d4978b30f25b41ee97b9d77bed0
```

Verify the currency contract has the proper initial balance
```
programs/eosc/eosc get table currency currency account
{
  "rows": [{
      "key": "account",
      "balance": 1000000000
    }
  ],
  "more": false
}

```

## Transfering funds with the sample "currency" contract

The content of the message is '{"from":"currency","to":"inita","quantity":99}'. In this case we are asking the currency contract to transfer funds from itself to someone else. This requires the permission of the currency contract.

```
programs/eosc/eosc push message currency transfer '{"from":"currency","to":"inita","quantity":99}' --scope currency,inita --permission currency@active    
1069775ms            main.cpp:1128                 operator()           ] Converting argument to binary...
{
  "transaction_id": "2c81c8369b338d1223c4c62102a27da8f35f43432176b3c0e4d6045747f7f8a1",
  ...
}
```

Now check the state of both of the accounts involved in the previous transaction.

```
programs/eosc/eosc get table inita currency account
{
  "rows": [{
      "key": "account",
      "balance": 99
    }
  ],
  "more": false
}
programs/eosc/eosc get table currency currency account
{
  "rows": [{
      "key": "account",
      "balance": 999999901
    }
  ],
  "more": false
}

```

As expected the receiving account inita now has a balance of 99 tokens, and the sending account now has 99 less tokens than its initial supply.